# ЭФМО-01-25 Буров М.А. ПР10

# Описание проекта
JWT-аутентификация: создание и проверка токенов. Middleware для авторизации

# Требования к проекту
* Go 1.25+
* Git

# Версия Go
<img width="317" height="55" alt="image" src="https://github.com/user-attachments/assets/43f9087b-95b9-4c7d-86e9-746258c45c63" />

# Команды запуска и переменные окружения

Linux/macOS:
```
export JWT_SECRET="dev-secret"
export ACCESS_TTL="15m"
export REFRESH_TTL="168h"
export APP_PORT="8080"
go run ./cmd/server
```

Windows PowerShell:
```
$env:JWT_SECRET="dev-secret"
$env:ACCESS_TTL="15m"
$env:REFRESH_TTL="168h"
$env:APP_PORT="8080"
go run ./cmd/server
```

# Цели:
- Понять устройство JWT и где его уместно применять в REST API. 
- Сгенерировать и проверить JWT в Go (HS256), передавать его в Authorization: Bearer …. 
- Реализовать middleware-аутентификацию (достаёт токен, валидирует, кладёт клеймы в context). 
- Добавить middleware-авторизацию (RBAC/права на эндпоинты). 
- Встроить это в уже знакомую архитектуру HTTP-сервиса/роутера.

# Структура проекта
Дерево структуры проекта: 
```
pz10-auth/
├── go.mod
├── go.sum
├── cmd/server/main.go
├── internal/
│   ├── core/
│   │   ├── user.go
│   │   └── service.go
│   ├── http/
│   │   ├── router.go
│   │   └── middleware/
│   │       ├── authn.go
│   │       └── authz.go
│   ├── repo/
│   │   └── user_mem.go
│   └── platform/
│       ├── config/config.go
│       └── jwt/jwt.go
└── README.md
```

# Скриншоты

Успешный /login администратора:

<img width="1380" height="638" alt="image" src="https://github.com/user-attachments/assets/8345ceae-8e0d-4cdf-9e26-4d3894701bf7" />

Успешный /login пользователя:

<img width="1369" height="647" alt="image" src="https://github.com/user-attachments/assets/144c77c6-282a-450c-8036-cfdd67d354bd" />

/me администратора:



/admin/stats администратора:

<img width="1363" height="569" alt="image" src="https://github.com/user-attachments/assets/20e228ef-93c5-4c32-ba5c-5e5bcb7d9e75" />

403 для user на /admin/stats:

<img width="1368" height="513" alt="image" src="https://github.com/user-attachments/assets/7d944520-b2a4-43cd-840c-70bb29b9efad" />

refresh-флоу (старый/новый access):

<img width="1359" height="626" alt="image" src="https://github.com/user-attachments/assets/81343d14-83f3-4577-a291-c6a69454bfa3" />



# Фрагменты кода

# Краткие выводы

Реализована полнофункциональная JWT-аутентификация с поддержкой двух типов токенов: short-lived access (15 мин) и long-lived refresh (7 дней). При логине система выдаёт обе токена; access используется для доступа к защищённым ресурсам, refresh позволяет обновить пару без повторного логина. Система хранит отозванные refresh-токены в in-memory blacklist, что позволяет реализовать корректный logout.

Реализована ABAC-авторизация (Attribute-Based Access Control) на примере эндпоинта /api/v1/users/{id}: пользователи с ролью user могут получить только собственный профиль (id == sub из токена), в то время как администраторы имеют полный доступ. Архитектура использует middleware-цепочку: AuthN (аутентификация через JWT) → AuthZ (авторизация через RBAC/ABAC), что разделяет ответственность и облегчает тестирование.

# Ответы на контрольные вопросы

1.	Что такое клеймы JWT и чем отличаются registered, public, private? Почему важно exp? 

Клеймы — это утверждения (assertions) в payload JWT. Каждый клейм — это пара ключ-значение, например "sub": "12345" (subject/пользователь) или "role": "admin".

Типы клеймов:

- Registered Claims — стандартные, определённые RFC 7519: sub (subject), exp (expiration time), iat (issued at), iss (issuer), aud (audience), jti (JWT ID). Они имеют специальное значение при валидации.

- Public Claims — определены по договорённости между сторонами, не конфликтуют со стандартными. Например, "email": "user@example.com", "role": "admin".

- Private Claims — кастомные клеймы, определённые для специфичного приложения. Например, "department": "IT", "subscription_level": "premium".

Почему важно exp (expiration time):

- exp указывает, до какого момента времени токен считается действительным (в секундах с Unix Epoch)

- Если exp прошёл, любое приложение должно отклонить токен, даже если подпись корректна

- Это защищает от использования украденного токена неопределённо долго

- При короткой exp (15 мин для access) даже если перехватят токен, окно компрометации ограничено

- При долгой exp (7 дней для refresh) пользователь не должен заново логиниться часто

2.	Чем stateless-аутентификация на JWT отличается от сессионных cookie на сервере? Плюсы/минусы. 

JWT (stateless):

- Сервер не хранит информацию о токенах

- Всё нужное зашифровано и подписано в самом токене

- Клиент отправляет токен в каждом запросе, сервер проверяет подпись

- Масштабируется легко: любой сервер может проверить токен без синхронизации состояния

Сессионные cookie (stateful):

- Сервер создаёт уникальный session_id и сохраняет его в памяти/БД

- Клиент получает session_id в cookie

- Клиент отправляет cookie, сервер ищет session_id в памяти

Плюсы JWT:

- Масштабируемость: не нужна синхронизация между серверами

- Мобильные приложения: можно хранить в памяти

- Микросервисы: токен проходит между сервисами без обращения к авторизационному сервису

- Простота CORS

Минусы JWT:

- Отзыв токена сложнее: нельзя просто удалить из памяти (нужен blacklist)

- Размер больше (сотни байт против 32-байтного session_id)

- Информация в токене видна (base64-закодирована, не зашифрована)

- Если ключ скомпрометирован, все выданные токены уязвимы

Плюсы сессий:

- Отзыв простой: удалил из памяти — готово

- Контроль на сервере: сложные правила авторизации легче реализовать

- Меньше сетевой нагрузки

Минусы сессий:

- Масштабируемость: все серверы должны синхронизировать состояние (Redis, БД)

- Дороже ресурсов: нужно хранить сессию на сервере

- Сложнее с микросервисами

3.	Как устроена цепочка middleware и почему AuthZ должна идти после AuthN? 

Цепочка middleware в Go (например, chi) работает как вложенные функции.

```
HTTP Request
    ↓
[Middleware 1: AuthN]
    ├─ Проверяет токен
    ├─ Кладёт claims в context
    ↓
[Middleware 2: AuthZ]
    ├─ Читает role из context
    ├─ Проверяет права
    ↓
[Handler]
    ├─ Логика эндпоинта
    ↓
Response
```

Почему AuthZ после AuthN:

- AuthN проверяет кто ты (валидирует токен, извлекает identity)

- AuthZ проверяет что ты можешь делать (проверяет права)

- Если токен невалиден → AuthN вернёт 401 Unauthorized, и AuthZ не будет вызван (экономия ресурсов)

- Если положить AuthZ перед AuthN, то AuthZ не найдёт claims в context → будет ошибка или неверная работа

- Логический порядок: сначала узнаём, кто запрашивает, потом проверяем его права

4.	RBAC vs ABAC: когда что выбирать? Примеры. 

RBAC (Role-Based Access Control):

- Доступ зависит только от роли пользователя

- Роли: admin, user, moderator, guest

- Правило: если роль == admin → разрешено

- Просто реализовать, но негибко

Примеры RBAC:

- Только admin может удалять пользователей: если role == "admin" → DELETE /users/{id}

- Только user может читать свои заметки: если role == "user" → GET /notes

- ABAC (Attribute-Based Access Control):

- Доступ зависит от атрибутов: владелец ресурса, роль, время, IP, и т.д.

- Правило может быть сложным: если (role == "user" И owner_id == sub) ИЛИ (role == "admin")

- Гибко, но сложнее реализовать

Примеры ABAC:

- User может читать только свой профиль: если role == "user" AND user_id == sub → GET /users/{id} ← это в нашем коде!

- Moderator может редактировать посты, созданные сегодня: если (role == "moderator" AND created_date == today) → PATCH /posts/{id}

- Admin может всё: если role == "admin" → всё разрешено

Когда RBAC:

- Простая система (несколько ролей, однозначные права)

- Все пользователи в роли имеют одинаковые права

- Быстрое прототипирование

Когда ABAC:

- Сложные правила доступа

- Нужен доступ на основе владельца ресурса

- Данные должны быть защищены по атрибутам (department, location, time)

5.	Как безопасно хранить пароль и почему нужен bcrypt/argon2 вместо SHA-256? (коснитесь соли/pepper). 

Почему bcrypt/Argon2 лучше SHA-256:

- Медленность — bcrypt/Argon2 специально спроектированы медленными. Перебор 100 млн паролей будет занимать месяцы, даже на GPU.

- SHA-256: 1 млрд хэшей/сек на GPU

- bcrypt (cost=12): 1000 хэшей/сек

- Встроенная соль: bcrypt автоматически генерирует случайную соль и встраивает её в результат. SHA-256 требует обработки соли отдельно.

- Адаптивность: cost-параметр в bcrypt можно увеличивать со временем (было cost=10, теперь cost=12), и это не сломает старые хэши.

Соль (salt):

- Это случайное число, добавляемое к паролю перед хэшированием

- Защищает от радужных таблиц (таблицы предвычисленных хэшей популярных паролей)

- Два одинаковых пароля с разными солями дадут разные хэши

- Bcrypt генерирует соль автоматически и встраивает в результат

Перец (pepper):

- Это серверный секрет, добавляемый к паролю + соль перед хэшированием

- Хранится отдельно от БД (например, в переменной окружения)

- Даже если БД утечёт, без pepper нельзя проверить пароли

- Используется редко (усложнение, но небольшой выигрыш)
